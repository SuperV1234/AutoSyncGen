\documentclass{report}
\usepackage{minted}
\usepackage{verbatim}
\usepackage{fullpage}
\usepackage{etoolbox}
\usepackage{lipsum}
\usepackage{graphicx}

\graphicspath{ {res/} }
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}} 

\begin{document}
    \begin{titlepage}

        \center

        \textsc{\LARGE Universita' degli Studi di Messina}\\[1.5cm] 
        \textsc{\Large Networking course project}\\[0.5cm] 

        \HRule \\[0.4cm]
        { \huge \bfseries AutoSyncGen}\\[0.1cm]

        {\large \today}
        \HRule \\[1.5cm]
         
        \begin{minipage}{0.4\textwidth}
        \begin{flushleft} \large
        \emph{Author:}\\
        Vittorio \textsc{Romeo} % Your name
        \end{flushleft}
        \end{minipage}
        ~
        \begin{minipage}{0.4\textwidth}
        \begin{flushright} \large
        \emph{Professors:} \\
        Antonio \textsc{Puliafito}

        Giovanni \textsc{Merlino}
        \end{flushright}
        \end{minipage}\\[4cm]

        \vfill

        \begin{minipage}{\linewidth}
            \centering
            \begin{minipage}{0.35\linewidth}
                \begin{figure}[H]
                    \center
                    \includegraphics[width=3cm, height=3cm]{logounime}
                    
                    http://unime.it
                \end{figure}
            \end{minipage}
            \hspace{0.27\linewidth}
            \begin{minipage}{0.35\linewidth}
                \begin{figure}[H]
                    \center
                    \includegraphics[width=3cm, height=3cm]{logovee}
                    
                    http://vittorioromeo.info
                \end{figure}
            \end{minipage}
        \end{minipage}\\[3cm]
    \end{titlepage}


    \pagenumbering{gobble}
    \tableofcontents
    \newpage
    \pagenumbering{arabic}
    
    \chapter{Introduction}
        What is \emph{AutoSyncGen} and what is it trying to achieve?
    
        \section{Problem}
            Many networked applications require \emph{constant synchronization} between the server and the connected clients. 
            Software such as \emph{multiplayer online games} completely rely on the fact that a synchronized state is maintained between the server and the players.
            Other applications that are not reliant on state synchronization may still benefit from such a system. 
            A \emph{basic chatroom program}, for example, may use state synchronization to keep track of sent messages and allow newly-connected users to browse the message history.

            Implementing state synchronization is not a trivial task. It it usually required to define a simple protocol that \emph{explicitly handles} state synchronization for all data structures. 

            This is usually achieved by explicitly coding serialization behavior and explicitly defining how packets should be created and read for every synchronizable objects. Even for small applications, maintaining and expanding the code using a similar approach can become difficult quickly.

        \section{Solution}
            The solution proposed in this papers is \emph{AutoSyncGen}, a \emph{C++14} library written using \emph{modern and idiomatic code}.
            The library allows developers to quickly define synchronizable data structures, and automatically deals with \emph{object lifetime management}, \emph{serialization} and \emph{deserialization}, packet \emph{creation} and \emph{reading}.

            By quickly specifying how object memory should be managed and the types of the synchronizable fields, \emph{AutoSyncGen} generates code at \emph{compile-time} to keep track of the entire application state and generate synchronization requests and responses that send the smallest amount of data required to fully synchronize the clients to the server.

            \newpage

            Here's an example of a synchronizable data structure defined using the AutoSyncGen library.

            \begin{minted}[mathescape, linenos, numbersep=5pt, gobble=2, frame=lines, framesep=2mm]{cpp}
    /// @brief Synchronizable data structure representing a chat message.
    struct Message : syn::SyncObj
    <
        // The fields types are passed as a variadic type list.

        int,            // messageID
        std::string,    // author
        std::string     // contents
    >
    {
        // Field proxies are generated via macros for convenience.

        SYN_PROXY(0, messageID);
        SYN_PROXY(1, author);
        SYN_PROXY(2, contents);
    };
            \end{minted}

            A shorter (but more preprocessor-heavy) construct can be used, which reduces code repetition.

            \begin{minted}[mathescape, linenos, numbersep=5pt, gobble=2, frame=lines, framesep=2mm]{cpp}
    /// @brief Synchronizable data structure representing a chat message.
    SYN_DEFINE_SYNCOBJ
    (
        // Name of data structure.
        Message,

        // Tuple of synchronizable fields.
        (
            (int, messageID),
            (std::string, author),
            (std::string, contents)
        )
    );
            \end{minted}

            The library is structured in such a way that most of the user code can be \emph{shared between the client and the server}. 
            It is not necessary to re-define data structures or lifetime management instructions twice.

        \section{Technologies used}
            C++14, which is the latest official C++ standard, released in 2 March 2014 \emph{(paper N3936)}, is the language of choice for AutoSyncGen.
            Like C++11, this newer standard is a huge step forward for the language. \emph{Smarter memory managament}, \emph{automatic type deduction}, and countless new programming and metaprogramming features allow developers to write much safer and powerful code.
            C++11 and C++14 features make AutoSyncGen possible.

            On top of C++14 and its standard library, the \emph{SSV framework} is being used as well. This framework was completely written from scratch by me, \emph{Vittorio Romeo}, and is available under the open-source AFL3.0 license on GitHub.

            The \emph{SSVUtils} library, used throughout the whole program, features many heterogeneous self-contained modules: an efficient and modern handwritten JSON parser, a preprocessor metaprogramming module, a template metaprogramming module, automatic console formatted output for containers and user-defined types, efficient data structures (bimap, handle vector, growable arrays), advanced memory management facilities, type-safe variadic unions, handwritten templating system, filesystem management, easy benchmarking of portions of code, and much more.

            Two additional dependencies for AutoSyncGen are the \emph{SFML} library, which offers lightweight abstraction over sockets and packets, and the \emph{SSVStart} library, part of the SSV framework, which extends the functionality of SFML and wraps some of its C++03 abstractions with more modern and safer C++14 constructs.
    
    \newpage

    \chapter{Network module}
        AutoSyncGen is divided in two main modules. 
        The \emph{network module} deals with client/server abstraction and communication, and will be covered in this chapter.
        The \emph{synchronization module} deals with compile-time synchronization data structures generation and synchronization algorithms, and will be covered in the next chapter.

        \section{SFML}
            As mentioned in the previous chapter, SFML is one of the dependencies of AutoSyncGen. 
            SFML offers convenient and type-safe wrappers over basic networking constructs such as \emph{sockets} and \emph{packets}.

            AutoSyncGen's network module extensively uses these abstractions to allow cross-platform compatibility and additional safety.

            \begin{minted}[mathescape, linenos, numbersep=5pt, gobble=2, frame=lines, framesep=2mm]{cpp}
    // SFML offers an `IpAddress` data structure that that can be initialized from strings.
    using sf::IpAddress;
    
    // SFML offers a `Packet` object that can be filled/emptied using stream operators.
    using sf::Packet;

    // SFML offers an `UdpSocket` class that properly manages and abstracts the memory 
    // and functionality of an UDP socket.
    using sf::UdpSocket;
            \end{minted}

            Just to clarify how convenient these abstractions are, here's a small code example that shows \emph{sf::Packet} usage.

            \begin{minted}[mathescape, linenos, numbersep=5pt, gobble=2, frame=lines, framesep=2mm]{cpp}
    int x{5};
    std::string y{"hello!"};
    double z{2.52};

    sf::Packet toSend;
    toSend >> x >> y >> z;

    // Send packet through the UDP socket...

    int outX; 
    std::string outY;
    double outZ;
    
    sf::Packet received;
    received << outX << outY << outZ;
            \end{minted}

            SFML is open-source, cross-platform and free.

        \section{Packets}
            AutoSyncGen uses a simple but effective protocol for data synchronization, which requires some special packets.

            \subsection{Packet types}
                Packet types are defined using \emph{C++11 enum classes}, which are type-safe enumeration types that cannot be implicitly converted to their underlying representation.

                \subsubsection{CtoS enumeration}
                    This enumeration holds the packet types that are sent from the client to the server.

                    \begin{minted}[mathescape, linenos, numbersep=5pt, gobble=2, frame=lines, framesep=2mm]{cpp}
    enum class CtoS : NType
    {
        // Request to establish a connection to the server
        ConnectionRequest = 0,      
        
        // Ping to avoid timing out with the server
        Ping = 1,                   

        // Request to sync data with server
        SyncRequest = 2,            
        
        // Informs the server that the syncronization was successful
        SyncSatisfied = 3,         

        // Custom data packet
        Data = 4,                   
    };
                    \end{minted}

                \subsubsection{StoC enumeration}
                    This enumeration holds the packet types that are sent from the server to the client.

                    \begin{minted}[mathescape, linenos, numbersep=5pt, gobble=2, frame=lines, framesep=2mm]{cpp}
    enum class StoC : NType
    {
        // Accept a requested client connection, assigning the client a CID
        ConnectionAccept = 0,       
        
        // Decline a client's requested connection
        ConnectionDecline = 1,      

        // Satisfy sync request (if the client's revision is behind)
        SyncRequestSatisfy = 2,     

        // Sync not needed (client has the same revision as the server)
        SyncRequestUnneeded = 3,    

        // Sync request declined (overload/technical issue)
        SyncRequestDecline = 4,     

        // Custom data packet
        Data = 5,                   
    };
                    \end{minted}
            
            \subsection{Packet handling}
                Packets are automatically handled by the client and the server, using a switch.

                \begin{minted}[mathescape, linenos, numbersep=5pt, gobble=2, frame=lines, framesep=2mm]{cpp}
    void handle(RPT mType)
    {
        switch(mType)
        {
            case RPT::ConnectionAccept:
                handleConnectionAccept();
                return;
            case RPT::ConnectionDecline:
                handleConnectionDecline();
                return;
            // ...
        }
    }
                \end{minted}

                This implementation is fine for the current packet types AutoSyncGen uses, but can be changed to a lookup table or an array of function pointers if more packet types need to be added in the future.

        \section{SessionHost}

            Clients and servers are abstracted as \emph{SessionHost} classes in the network module.
            The \emph{SessionHost} classes defines data structures and functionality shared both by clients and servers.

            Every host has a dedicated extra thread for data and socket management.

\begin{minted}[mathescape, linenos, numbersep=5pt, gobble=2, frame=lines, framesep=2mm]{cpp}
    // `SessionHost` is a CRTP template class, to allow compile-time generation 
    // of appropriate data structures.
    template
    <
        // `struct` containing global synchronization settings.
        typename TSettings, 
        
        // Type of sent packets.
        typename TSPT, 
        
        // Type of received packets.
        typename TRPT, 

        // CRTP (curiously recurring template pattern) derived type.
        template<typename> class TDerivedBase
    > 
    class SessionHost
    {
        // Typedefs of data structures that depend on the template parameters.
        public:
            // CRTP type.
            using Derived = TDerivedBase<Settings>;

            // Packet types.
            using SPT = TSPT;
            using RPT = TRPT;
        
            // Synchronization classes.
            using Settings = TSettings;
            using SyncManager = typename Settings::SyncManager;
            using Diff = typename SyncManager::DiffType;
            using Snapshot = typename SyncManager::SnapshotType;

        private:
            // Name of the host.
            std::string name;
            
            // IP address of the host.
            IpAddress ip;

            // Port the host is listening on.
            Port port;

            // UDP socket of the host.
            UdpSocket socket;

            // Status of the host.
            bool busy{false};

            // Tries binding the socket to the specified port.
            void tryBindSocket();    

            // Tries forwarding the received packets to the underlying 
            // client/server implementation.
            void tryForwardReceivedPacket();
            
            // Function running in the receive thread, which keeps track
            // of the data receiving buffer and of the socket state.
            void receiveThread();

        protected:
            // Buffers that store received data and data that will be sent.
            Packet sendBuffer, recvBuffer;

            // `void` future offering a RAII wrapper for the host's thread.
            std::future<void> hostFuture;

            // IP of the sender of the last received data.
            IpAddress senderIp;
            
            // Port of the sender of the last received data.
            Port senderPort;
            
            // Synchronization manager.
            SyncManager syncManager;

            // Sends the content of the send buffer to the specified host.
            void sendTo(const IpAddress& mIp, const Port& mPort);

            // Builds a packet from a variadic argument list.
            template<SPT TType, typename... TArgs> void mkPacket(TArgs&&... mArgs);

            // Sets the state of the host.
            void setBusy(bool mBusy) noexcept { busy = mBusy; }

            // Pops data of type `T` from the receive buffer.
            template<typename T> auto popRecv();

        public:
            // Constructs the host using a specified name and port.
            // This function tries to bind the socket and start the dedicated thread.
            SessionHost(std::string mName, syn::Port mPort);

            // Getters.
            const auto& getName() const noexcept;
            const auto& getIp() const noexcept;
            const auto& getPort() const noexcept;
            const auto& isBusy() const noexcept;
            auto& getSyncManager() noexcept;
    };

    // Template typedef for the base `SessionHost` used by servers.
    template<typename TSettings> 
    using SessionServerBase = SessionHost<TSettings, PT::StoC, PT::CtoS, SessionServer>;

    // Template typedef for the base `SessionHost` used by clients.
    template<typename TSettings> 
    using SessionClientBase = SessionHost<TSettings, PT::CtoS, PT::StoC, SessionClient>;
\end{minted}

            \subsection{SessionServer}

                The \emph{SessionServer} CTRP derivation of \emph{SessionHost} requires additional data structures and algorithms to deal with client connections and storage of the client's latest synchronization state snapshots.

                \subsubsection{ClientHandler}

                    A \emph{ClientHandler} instance is created and managed for every client connected to the server.

\begin{minted}[mathescape, linenos, numbersep=5pt, gobble=2, frame=lines, framesep=2mm]{cpp}
    class ClientHandler
    {
        private:
            // Connect client ID. 
            // Assigned by the server.
            CID cid{nullCID};

            // IP and Port of the client.
            IpAddress ip;
            Port port;

            // Seconds until the client is timed out.
            int secondsUntilTimeout;
            
            // State of the client handler.
            bool busy{false};

        public:
            // Assumes the handler is not busy and binds it to a client with a
            // specific client ID, IP and Port.
            void bindToClient(CID mCID, const IpAddress& mIp, const Port& mPort);

            // Unbinds the handler from the client connection.
            void unbindFromClient();

            // Getters
            const auto& getCID() const noexcept;
            const auto& getIp() const noexcept;
            const auto& getPort() const noexcept;
    };
\end{minted}

                    Client handlers are stored and managed in the \emph{ClientHandlerManager} class, of which the server has an instance.

                \subsubsection{ClientHandlerManager}

                    The \emph{ClientHandlerManager} manages memory and functionality of \emph{ClientHandler} instances.
                    A \emph{ssvu::MonoRecycler} is used to store the handlers on the heap and recycle their memory.
                    The manager also stores two vector of pointers to client handlers: one with non-busy handlers, and one with busy handlers.
                    The lists are periodically checked by an extra thread to remove timed-out client handlers and to accept new connections.

\begin{minted}[mathescape, linenos, numbersep=5pt, gobble=2, frame=lines, framesep=2mm]{cpp}
    class ClientHandlerManager
    {
        private:
            // Next available unique client ID. 
            CID nextCID{0};

            // Memory management and recycling data structure for `ClientHandler` instances.
            ssvu::MonoManager<ClientHandler> clientHandlers;

            // Vector of non-busy client handlers.
            std::vector<ClientHandler*> chAvailable
            
            // Vector of busy client handlers.
            std::vector<ClientHandler*> chBusy;
            
            // Map of client handlers, by client ID.
            std::map<CID, ClientHandler*> chMap;

            // `void` future that wraps the thread which checks timeouts for client handlers.
            std::future<void> timeoutFuture;

            // Vector of client handler IDs that need to be disconnected.
            std::vector<CID> toDisconnect;

            // State of the client handler manager.
            bool busy{true};

            // Creates a client handler instance from the `MonoManager`
            // and inserts it into the available vector.
            void createClientHandler();
            
            // Method ran in the timeout thread.
            // Periodically checks if clients have timed out.
            void runTimeout();

        public: 
            // Accepts a new client connection.
            // Uses an existing free handler, if available, otherwise allocates a new one.
            // Also removes all handlers that have to be disconnected and updates the ID map.
            auto& acceptClient(const IpAddress& mIp, const Port& mPort);

            // Returns true if an handler exists, by ID.
            bool has(CID mCID) const noexcept;

            // Gets a client handler by ID.
            auto& operator[](CID mCID) noexcept;

            // Refreshes the timeout duration when a ping is received for a specific client.
            void pingReceived(CID mCID) noexcept;
    };
\end{minted}
            
            \subsection{SessionClient}

                The \emph{SessionClient} CTRP derivation of \emph{SessionHost} does not require any particular additional data structure. The only additions, compared to the \emph{SessionHost} base class, are the IP and Port of the currentserver.

    \newpage

    \chapter{Synchronization module}
        \section{ssvu}

        \section{SerializationHelper}

        \section{SyncObj}
            \subsection{Fields}
                \subsubsection{Field tuple}
                \subsubsection{Field flags}
                \subsubsection{FieldProxy}
        
        \section{Snapshot}
            \subsection{SnapshotTypeData}
                \subsubsection{Item map}
            
        \section{Diff}
            \subsection{DiffTypeData}
                \subsubsection{toCreate map}

                \subsubsection{toUpdate map}

                \subsubsection{toRemove vector}
        
        \section{LifetimeManager}

        \section{SyncManager}
            \subsection{Lifetime managers tuple}

            \subsection{Handle maps tuple}

            \subsection{Object management functions}

    \newpage

    \chapter{Example application: synchronized chat}
        \section{Data structures}
            \subsection{Message}

        \section{Lifetime manager specialization}
            \subsection{Pointers as handles}
            
            \subsection{create}

            \subsection{remove}

        \section{Application packet types}
            \subsection{Server to client}

            \subsection{Client to server}

        \section{ConsoleSessionController}
            \subsection{Server role}

            \subsection{Client role}
        
    \newpage

\end{document}
